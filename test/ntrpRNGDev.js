/**
 * ntrpRNGDev.js - Development & Testing Suite for ntrpRNG
 * 
 * Provides comprehensive statistical analysis and stress testing tools
 * for validating the quality of seeds generated by ntrpRNG.js and cgRNDV.js.
 * 
 * @version 1.5.0
 * @license MIT
 * @requires ntrpRNG.js v1.3.0+ or cgRNDV.js v1.1.0+
 * 
 * CHANGELOG:
 *
 * v1.5.0 - BREAKING: Removed backward compatibility with ntrpRNG < 1.3.0
 *        - Added weighted event counting awareness and proper logging
 *        - Now uses getProgress() API instead of manual calculations
 *        - New Test 7: verifyIntegrityChecks() - validates security constants
 *        - New Test 8: verifyAPICompatibility() - ensures RNG interchangeability
 *        - Enhanced RNG type detection with weighted counting support
 *        - Updated all logging to distinguish "weighted events" vs "raw events"
 *        - runTestSuite() now includes 8 tests (6 universal + 2 behavioral-only)
 *        - Documentation references updated to ntrpRNG 1.3.0 and cgRNDV 1.1.0
 * v1.4.0 - Added Chi-Square, Serial Correlation, and Avalanche Effect tests
 *        - Integrated new tests into runTestSuite() with level-based parameters
 *        - Added concatenated mode support for Chi-Square and Serial Correlation
 * v1.3.0 - Added universal support for both ntrpRNG and cgRNDV
 *        - Auto-detection of RNG type (behavioral vs pure-crypto)
 *        - Conditional test execution based on RNG capabilities
 * v1.2.1 - Renamed library to ntrpRNGDev.js for naming consistency
 * v1.2.0 - Extended concatenated mode to all statistical tests
 * v1.1.0 - Added concatenated mode to Shannon Entropy test
 */

class ntrpRNGDev {
  constructor(rngInstance) {
    if (!rngInstance || typeof rngInstance.generateSeed !== 'function') {
      throw new Error('ntrpRNGDev requires a valid RNG instance (ntrpRNG v1.3.0+ or cgRNDV v1.1.0+)');
    }
    this.rng = rngInstance;
    this.testResults = [];
    
    // Detect RNG type and capabilities
    this.rngType = this._detectRNGType();
    this.usesWeightedCounting = this._detectWeightedCounting();
    
    console.log(`Detected RNG type: ${this.rngType}`);
    if (this.usesWeightedCounting) {
      console.log(`Weighted event counting: enabled`);
    }
  }
  
  _detectRNGType() {
    const hasBehavioralEntropy = 
      Array.isArray(this.rng.entropyPool) && 
      Array.isArray(this.rng.timerDeltas) &&
      typeof this.rng.eventCount === 'object';
    
    return hasBehavioralEntropy ? 'behavioral' : 'pure-crypto';
  }
  
  _detectWeightedCounting() {
    if (this.rngType === 'pure-crypto') return false;
    
    // Check if RNG has _getWeightedEventCount method (ntrpRNG 1.3.0+)
    return typeof this.rng._getWeightedEventCount === 'function';
  }
  
  _getEntropyProgress() {
    // Use getProgress() API if available
    if (typeof this.rng.getProgress === 'function') {
      return this.rng.getProgress();
    }
    
    // Fallback for older versions (should not happen with v1.5.0)
    const stats = this.rng.getStats();
    return {
      currentEvents: stats.totalEvents || 0,
      requiredEvents: stats.minEvents || 500,
      percentage: Math.min(100, ((stats.totalEvents || 0) / (stats.minEvents || 500)) * 100),
      ready: stats.hasMinimumEntropy || false
    };
  }
  
  supportsBehavioralTests() {
    return this.rngType === 'behavioral';
  }
  
  _calculateShannonEntropy(data) {
    const frequency = new Array(256).fill(0);
    
    for (let i = 0; i < data.length; i++) {
      frequency[data[i]]++;
    }
    
    let entropy = 0;
    const len = data.length;
    
    for (let i = 0; i < 256; i++) {
      if (frequency[i] > 0) {
        const p = frequency[i] / len;
        entropy -= p * Math.log2(p);
      }
    }
    
    return entropy;
  }
  
  _monobitTest(data) {
    let onesCount = 0;
    let totalBits = data.length * 8;
    
    for (let i = 0; i < data.length; i++) {
      let byte = data[i];
      for (let j = 0; j < 8; j++) {
        onesCount += (byte >> j) & 1;
      }
    }
    
    const zerosCount = totalBits - onesCount;
    const sum = onesCount - zerosCount;
    const statistic = Math.abs(sum) / Math.sqrt(totalBits);
    
    return statistic;
  }
  
  _runsTest(data) {
    let bits = [];
    
    for (let i = 0; i < data.length; i++) {
      let byte = data[i];
      for (let j = 0; j < 8; j++) {
        bits.push((byte >> j) & 1);
      }
    }
    
    const n = bits.length;
    let onesCount = bits.reduce((a, b) => a + b, 0);
    let pi = onesCount / n;
    
    let runs = 1;
    for (let i = 1; i < n; i++) {
      if (bits[i] !== bits[i - 1]) {
        runs++;
      }
    }
    
    const expectedRuns = 2 * n * pi * (1 - pi) + 1;
    const variance = 2 * n * pi * (1 - pi) * (2 * n * pi * (1 - pi) - 1) / (n - 1);
    
    if (variance === 0) return 0;
    
    const statistic = Math.abs(runs - expectedRuns) / Math.sqrt(variance);
    return statistic;
  }
  
  _chiSquareTest(data) {
    const frequency = new Array(256).fill(0);
    
    for (let i = 0; i < data.length; i++) {
      frequency[data[i]]++;
    }
    
    const expected = data.length / 256;
    
    let chiSquare = 0;
    for (let i = 0; i < 256; i++) {
      const diff = frequency[i] - expected;
      chiSquare += (diff * diff) / expected;
    }
    
    return chiSquare;
  }
  
  _serialCorrelationTest(data) {
    let bits = [];
    
    for (let i = 0; i < data.length; i++) {
      let byte = data[i];
      for (let j = 0; j < 8; j++) {
        bits.push((byte >> j) & 1);
      }
    }
    
    const n = bits.length;
    if (n < 2) return 0;
    
    const mean = bits.reduce((a, b) => a + b, 0) / n;
    
    let sumXY = 0;
    let sumX2 = 0;
    
    for (let i = 0; i < n - 1; i++) {
      const x = bits[i] - mean;
      const y = bits[i + 1] - mean;
      sumXY += x * y;
      sumX2 += x * x;
    }
    
    if (sumX2 === 0) return 0;
    
    const correlation = sumXY / sumX2;
    return Math.abs(correlation);
  }
  
  _calculateStdDev(values) {
    const mean = values.reduce((a, b) => a + b, 0) / values.length;
    const variance = values.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / values.length;
    return Math.sqrt(variance);
  }
  
  async runMultiSeedTest(count = 10, seedSize = 64, concatenated = false) {
    console.log(`\n=== Multi-Seed Test ===`);
    console.log(`RNG Type: ${this.rngType}`);
    console.log(`Generating ${count} seeds of ${seedSize} bytes each...`);
    console.log(`Test mode: ${concatenated ? 'CONCATENATED' : 'INDIVIDUAL'}`);
    
    const shannonScores = [];
    const monobitScores = [];
    const runsScores = [];
    const chiSquareScores = [];
    const serialCorrScores = [];
    const seeds = [];
    
    const startTime = performance.now();
    
    for (let i = 0; i < count; i++) {
      try {
        const seed = await this.rng.generateSeed(true);
        const truncatedSeed = seed.slice(0, seedSize);
        seeds.push(truncatedSeed);
        
        if (!concatenated) {
          const shannon = this._calculateShannonEntropy(truncatedSeed);
          const monobit = this._monobitTest(truncatedSeed);
          const runs = this._runsTest(truncatedSeed);
          const chiSquare = this._chiSquareTest(truncatedSeed);
          const serialCorr = this._serialCorrelationTest(truncatedSeed);
          
          shannonScores.push(shannon);
          monobitScores.push(monobit);
          runsScores.push(runs);
          chiSquareScores.push(chiSquare);
          serialCorrScores.push(serialCorr);
        }
        
        if ((i + 1) % Math.max(1, Math.floor(count / 10)) === 0) {
          console.log(`Progress: ${i + 1}/${count} seeds generated`);
        }
      } catch (error) {
        console.error(`Error generating seed ${i + 1}:`, error.message);
      }
    }
    
    if (concatenated && seeds.length > 0) {
      const totalSize = seeds.reduce((sum, seed) => sum + seed.length, 0);
      const concatenatedData = new Uint8Array(totalSize);
      
      let offset = 0;
      for (let seed of seeds) {
        concatenatedData.set(seed, offset);
        offset += seed.length;
      }
      
      console.log(`Concatenated dataset size: ${totalSize} bytes`);
      console.log(`Running tests on concatenated dataset...`);
      
      shannonScores.push(this._calculateShannonEntropy(concatenatedData));
      monobitScores.push(this._monobitTest(concatenatedData));
      runsScores.push(this._runsTest(concatenatedData));
      chiSquareScores.push(this._chiSquareTest(concatenatedData));
      serialCorrScores.push(this._serialCorrelationTest(concatenatedData));
    }
    
    const endTime = performance.now();
    const duration = (endTime - startTime) / 1000;
    
    const results = {
      rngType: this.rngType,
      count: seeds.length,
      seedSize: seedSize,
      duration: duration.toFixed(2) + 's',
      concatenatedMode: concatenated,
      shannonEntropy: concatenated ? {
        value: shannonScores[0].toFixed(4),
        datasetSize: seeds.length * seedSize + ' bytes',
        ideal: '7.9-8.0 bits/byte'
      } : {
        mean: (shannonScores.reduce((a, b) => a + b, 0) / shannonScores.length).toFixed(4),
        stdDev: this._calculateStdDev(shannonScores).toFixed(4),
        min: Math.min(...shannonScores).toFixed(4),
        max: Math.max(...shannonScores).toFixed(4),
        ideal: '7.9-8.0 bits/byte'
      },
      monobitTest: concatenated ? {
        value: monobitScores[0].toFixed(4),
        datasetSize: seeds.length * seedSize + ' bytes',
        ideal: '< 2.0 (closer to 0)'
      } : {
        mean: (monobitScores.reduce((a, b) => a + b, 0) / monobitScores.length).toFixed(4),
        stdDev: this._calculateStdDev(monobitScores).toFixed(4),
        min: Math.min(...monobitScores).toFixed(4),
        max: Math.max(...monobitScores).toFixed(4),
        ideal: '< 2.0 (closer to 0)'
      },
      runsTest: concatenated ? {
        value: runsScores[0].toFixed(4),
        datasetSize: seeds.length * seedSize + ' bytes',
        ideal: '< 2.0 (lower is better)'
      } : {
        mean: (runsScores.reduce((a, b) => a + b, 0) / runsScores.length).toFixed(4),
        stdDev: this._calculateStdDev(runsScores).toFixed(4),
        min: Math.min(...runsScores).toFixed(4),
        max: Math.max(...runsScores).toFixed(4),
        ideal: '< 2.0 (lower is better)'
      },
      chiSquareTest: concatenated ? {
        value: chiSquareScores[0].toFixed(4),
        datasetSize: seeds.length * seedSize + ' bytes',
        ideal: '< 293.25 (95% confidence)'
      } : {
        mean: (chiSquareScores.reduce((a, b) => a + b, 0) / chiSquareScores.length).toFixed(4),
        stdDev: this._calculateStdDev(chiSquareScores).toFixed(4),
        min: Math.min(...chiSquareScores).toFixed(4),
        max: Math.max(...chiSquareScores).toFixed(4),
        ideal: '< 293.25 (95% confidence)'
      },
      serialCorrelationTest: concatenated ? {
        value: serialCorrScores[0].toFixed(4),
        datasetSize: seeds.length * seedSize + ' bytes',
        ideal: '< 0.1 (closer to 0)'
      } : {
        mean: (serialCorrScores.reduce((a, b) => a + b, 0) / serialCorrScores.length).toFixed(4),
        stdDev: this._calculateStdDev(serialCorrScores).toFixed(4),
        min: Math.min(...serialCorrScores).toFixed(4),
        max: Math.max(...serialCorrScores).toFixed(4),
        ideal: '< 0.1 (closer to 0)'
      }
    };
    
    console.log('\nResults:');
    console.log(`Seeds Generated: ${results.count}`);
    console.log(`Duration: ${results.duration}`);
    
    if (concatenated) {
      console.log(`\nShannon Entropy (Concatenated): ${results.shannonEntropy.value} (${results.shannonEntropy.ideal})`);
      console.log(`  Dataset: ${results.shannonEntropy.datasetSize}`);
      console.log(`\nMonobit Test (Concatenated): ${results.monobitTest.value} (${results.monobitTest.ideal})`);
      console.log(`  Dataset: ${results.monobitTest.datasetSize}`);
      console.log(`\nRuns Test (Concatenated): ${results.runsTest.value} (${results.runsTest.ideal})`);
      console.log(`  Dataset: ${results.runsTest.datasetSize}`);
      console.log(`\nChi-Square Test (Concatenated): ${results.chiSquareTest.value} (${results.chiSquareTest.ideal})`);
      console.log(`  Dataset: ${results.chiSquareTest.datasetSize}`);
      console.log(`\nSerial Correlation (Concatenated): ${results.serialCorrelationTest.value} (${results.serialCorrelationTest.ideal})`);
      console.log(`  Dataset: ${results.serialCorrelationTest.datasetSize}`);
    } else {
      console.log(`\nShannon Entropy (Individual): ${results.shannonEntropy.mean} ± ${results.shannonEntropy.stdDev} (${results.shannonEntropy.ideal})`);
      console.log(`  Range: [${results.shannonEntropy.min}, ${results.shannonEntropy.max}]`);
      console.log(`\nMonobit Test (Individual): ${results.monobitTest.mean} ± ${results.monobitTest.stdDev} (${results.monobitTest.ideal})`);
      console.log(`  Range: [${results.monobitTest.min}, ${results.monobitTest.max}]`);
      console.log(`\nRuns Test (Individual): ${results.runsTest.mean} ± ${results.runsTest.stdDev} (${results.runsTest.ideal})`);
      console.log(`  Range: [${results.runsTest.min}, ${results.runsTest.max}]`);
      console.log(`\nChi-Square Test (Individual): ${results.chiSquareTest.mean} ± ${results.chiSquareTest.stdDev} (${results.chiSquareTest.ideal})`);
      console.log(`  Range: [${results.chiSquareTest.min}, ${results.chiSquareTest.max}]`);
      console.log(`\nSerial Correlation (Individual): ${results.serialCorrelationTest.mean} ± ${results.serialCorrelationTest.stdDev} (${results.serialCorrelationTest.ideal})`);
      console.log(`  Range: [${results.serialCorrelationTest.min}, ${results.serialCorrelationTest.max}]`);
    }
    
    this.testResults.push({ test: 'MultiSeed', timestamp: Date.now(), results });
    return results;
  }
  
  async monitorEntropyPool(intervalMs = 100, maxSamples = 30) {
    if (!this.supportsBehavioralTests()) {
      console.log(`\n=== Entropy Pool Monitor ===`);
      console.log(`SKIPPED: ${this.rngType} RNG does not collect behavioral entropy`);
      return;
    }
    
    console.log(`\n=== Entropy Pool Monitor ===`);
    console.log(`Sampling every ${intervalMs}ms for ${maxSamples} samples...`);
    if (this.usesWeightedCounting) {
      console.log(`Note: Events are weighted (keyboard=3, mouse_down/touch/motion=2, move/scroll=1)`);
    }
    
    const samples = [];
    let sampleCount = 0;
    
    return new Promise((resolve) => {
      const intervalId = setInterval(() => {
        const progress = this._getEntropyProgress();
        const stats = this.rng.getStats();
        
        const sample = {
          timestamp: Date.now(),
          poolSize: stats.entropyPoolSize,
          timerSize: stats.timerDeltasSize,
          totalEvents: progress.currentEvents,
          progress: progress.percentage.toFixed(1) + '%'
        };
        
        samples.push(sample);
        
        if (samples.length > 1) {
          const poolSizes = samples.map(s => s.poolSize);
          const poolVariance = this._calculateStdDev(poolSizes);
          
          console.log(
            `Sample ${samples.length}/${maxSamples}: ` +
            `Pool=${sample.poolSize}, Timer=${sample.timerSize}, ` +
            `Events=${sample.totalEvents}${this.usesWeightedCounting ? ' (weighted)' : ''}, ` +
            `Progress=${sample.progress}, Variance=${poolVariance.toFixed(2)}`
          );
        } else {
          console.log(
            `Sample ${samples.length}/${maxSamples}: ` +
            `Pool=${sample.poolSize}, Timer=${sample.timerSize}, ` +
            `Events=${sample.totalEvents}${this.usesWeightedCounting ? ' (weighted)' : ''}, ` +
            `Progress=${sample.progress}`
          );
        }
        
        sampleCount++;
        
        if (sampleCount >= maxSamples) {
          clearInterval(intervalId);
          
          const poolSizes = samples.map(s => s.poolSize);
          const timerSizes = samples.map(s => s.timerSize);
          
          console.log('\nFinal Statistics:');
          console.log(`Pool Size - Mean: ${(poolSizes.reduce((a,b)=>a+b,0)/poolSizes.length).toFixed(2)}, ` +
                      `StdDev: ${this._calculateStdDev(poolSizes).toFixed(2)}`);
          console.log(`Timer Size - Mean: ${(timerSizes.reduce((a,b)=>a+b,0)/timerSizes.length).toFixed(2)}, ` +
                      `StdDev: ${this._calculateStdDev(timerSizes).toFixed(2)}`);
          
          resolve();
        }
      }, intervalMs);
    });
  }
  
  async verifySaltConsistency(iterations = 100) {
    console.log(`\n=== Salt Consistency Test ===`);
    console.log(`RNG Type: ${this.rngType}`);
    console.log(`Generating ${iterations} salts...`);
    
    const saltHashes = new Set();
    const saltLengths = [];
    let collisions = 0;
    
    const startTime = performance.now();
    
    for (let i = 0; i < iterations; i++) {
      const salt = this.rng.generateSalt();
      saltLengths.push(salt.length);
      
      const saltBuffer = await crypto.subtle.digest('SHA-256', salt);
      const saltHash = this.rng.toHex(new Uint8Array(saltBuffer));
      
      if (saltHashes.has(saltHash)) {
        collisions++;
        console.warn(`Collision detected at iteration ${i + 1}`);
      }
      
      saltHashes.add(saltHash);
      
      if ((i + 1) % Math.max(1, Math.floor(iterations / 10)) === 0) {
        console.log(`Progress: ${i + 1}/${iterations} salts generated`);
      }
    }
    
    const endTime = performance.now();
    const duration = (endTime - startTime) / 1000;
    
    const uniqueCount = saltHashes.size;
    const collisionRate = (collisions / iterations * 100).toFixed(4);
    const avgLength = (saltLengths.reduce((a, b) => a + b, 0) / saltLengths.length).toFixed(2);
    
    const results = {
      rngType: this.rngType,
      iterations,
      uniqueSalts: uniqueCount,
      collisions,
      collisionRate: collisionRate + '%',
      averageLength: avgLength + ' bytes',
      duration: duration.toFixed(2) + 's',
      passed: collisions === 0
    };
    
    console.log('\nResults:');
    console.log(`Total Salts: ${iterations}`);
    console.log(`Unique Salts: ${uniqueCount}`);
    console.log(`Collisions: ${collisions} (${collisionRate}%)`);
    console.log(`Average Length: ${avgLength} bytes`);
    console.log(`Duration: ${results.duration}`);
    console.log(`Test Status: ${results.passed ? 'PASSED ✓' : 'FAILED ✗'}`);
    
    this.testResults.push({ test: 'SaltConsistency', timestamp: Date.now(), results });
    return results;
  }
  
  async analyzeTimingJitter(samples = 100) {
    if (!this.supportsBehavioralTests()) {
      console.log(`\n=== Timing Jitter Analysis ===`);
      console.log(`SKIPPED: ${this.rngType} RNG does not collect timing jitter`);
      return { skipped: true, reason: 'Not supported by ' + this.rngType };
    }
    
    console.log(`\n=== Timing Jitter Analysis ===`);
    console.log(`Collecting ${samples} timing samples...`);
    
    const wasCollecting = this.rng.isCollecting;
    if (!wasCollecting) {
      this.rng.startCollecting();
    }
    
    await new Promise(resolve => setTimeout(resolve, 100));
    
    const waitTime = Math.min(samples * 2, 3000);
    await new Promise(resolve => setTimeout(resolve, waitTime));
    
    const timerDeltas = this.rng.timerDeltas || [];
    const recentDeltas = timerDeltas.slice(-Math.min(samples, timerDeltas.length));
    
    if (recentDeltas.length === 0) {
      console.warn('No timer deltas collected. Ensure RNG is collecting.');
      return { error: 'No data collected' };
    }
    
    const min = Math.min(...recentDeltas);
    const max = Math.max(...recentDeltas);
    const mean = recentDeltas.reduce((a, b) => a + b, 0) / recentDeltas.length;
    const stdDev = this._calculateStdDev(recentDeltas);
    
    const binCount = 10;
    const binSize = (max - min) / binCount;
    const histogram = new Array(binCount).fill(0);
    
    for (let delta of recentDeltas) {
      const binIndex = Math.min(Math.floor((delta - min) / binSize), binCount - 1);
      histogram[binIndex]++;
    }
    
    const results = {
      rngType: this.rngType,
      samplesAnalyzed: recentDeltas.length,
      min: min.toFixed(4),
      max: max.toFixed(4),
      mean: mean.toFixed(4),
      stdDev: stdDev.toFixed(4),
      range: (max - min).toFixed(4),
      coefficientOfVariation: ((stdDev / mean) * 100).toFixed(2) + '%',
      histogram: histogram
    };
    
    console.log('\nResults:');
    console.log(`Samples Analyzed: ${results.samplesAnalyzed}`);
    console.log(`Min: ${results.min}ms`);
    console.log(`Max: ${results.max}ms`);
    console.log(`Mean: ${results.mean}ms`);
    console.log(`StdDev: ${results.stdDev}ms`);
    console.log(`Range: ${results.range}ms`);
    console.log(`Coefficient of Variation: ${results.coefficientOfVariation}`);
    console.log('\nHistogram:');
    histogram.forEach((count, i) => {
      const binStart = (min + i * binSize).toFixed(2);
      const binEnd = (min + (i + 1) * binSize).toFixed(2);
      const bar = '█'.repeat(Math.ceil(count / Math.max(...histogram) * 40));
      console.log(`[${binStart}-${binEnd}]: ${bar} (${count})`);
    });
    
    if (!wasCollecting) {
      this.rng.stopCollecting();
    }
    
    this.testResults.push({ test: 'TimingJitter', timestamp: Date.now(), results });
    return results;
  }
  
  async checkRepeatability(iterations = 2) {
    console.log(`\n=== Repeatability Check ===`);
    console.log(`RNG Type: ${this.rngType}`);
    console.log(`Testing ${iterations} seed generations for uniqueness...`);
    
    const seeds = [];
    const seedHashes = new Set();
    let repeats = 0;
    
    const startTime = performance.now();
    
    for (let i = 0; i < iterations; i++) {
      const seed = await this.rng.generateSeed(true);
      
      const seedBuffer = await crypto.subtle.digest('SHA-256', seed);
      const seedHash = this.rng.toHex(new Uint8Array(seedBuffer));
      
      if (seedHashes.has(seedHash)) {
        repeats++;
        console.warn(`REPEAT DETECTED at iteration ${i + 1}!`);
        console.warn(`Seed hash: ${seedHash.substring(0, 32)}...`);
      }
      
      seeds.push(seed);
      seedHashes.add(seedHash);
      
      console.log(`Seed ${i + 1}: ${this.rng.toHex(seed).substring(0, 32)}...`);
      
      await new Promise(resolve => setTimeout(resolve, 50));
    }
    
    const endTime = performance.now();
    const duration = (endTime - startTime) / 1000;
    
    const hammingDistances = [];
    for (let i = 1; i < seeds.length; i++) {
      let distance = 0;
      for (let j = 0; j < Math.min(seeds[i-1].length, seeds[i].length); j++) {
        const xor = seeds[i-1][j] ^ seeds[i][j];
        distance += xor.toString(2).split('1').length - 1;
      }
      hammingDistances.push(distance);
    }
    
    const avgHammingDistance = hammingDistances.length > 0
      ? (hammingDistances.reduce((a, b) => a + b, 0) / hammingDistances.length).toFixed(2)
      : 'N/A';
    
    const results = {
      rngType: this.rngType,
      iterations,
      uniqueSeeds: seedHashes.size,
      repeats,
      repeatRate: ((repeats / iterations) * 100).toFixed(2) + '%',
      averageHammingDistance: avgHammingDistance + ' bits',
      duration: duration.toFixed(2) + 's',
      passed: repeats === 0
    };
    
    console.log('\nResults:');
    console.log(`Total Seeds: ${iterations}`);
    console.log(`Unique Seeds: ${results.uniqueSeeds}`);
    console.log(`Repeats: ${repeats}`);
    console.log(`Repeat Rate: ${results.repeatRate}`);
    console.log(`Avg Hamming Distance: ${avgHammingDistance} bits`);
    console.log(`Duration: ${results.duration}`);
    console.log(`Test Status: ${results.passed ? 'PASSED ✓' : 'FAILED ✗'}`);
    
    this.testResults.push({ test: 'Repeatability', timestamp: Date.now(), results });
    return results;
  }
  
  async testAvalancheEffect(iterations = 10) {
    console.log(`\n=== Avalanche Effect Test ===`);
    console.log(`RNG Type: ${this.rngType}`);
    console.log(`Analyzing ${iterations} seed pairs for bit-flip propagation...`);
    
    const avalancheScores = [];
    
    const startTime = performance.now();
    
    for (let i = 0; i < iterations; i++) {
      const seed1 = await this.rng.generateSeed(true);
      
      await new Promise(resolve => setTimeout(resolve, 10));
      
      const seed2 = await this.rng.generateSeed(true);
      
      const minLength = Math.min(seed1.length, seed2.length);
      let flippedBits = 0;
      
      for (let j = 0; j < minLength; j++) {
        const xor = seed1[j] ^ seed2[j];
        flippedBits += xor.toString(2).split('1').length - 1;
      }
      
      const totalBits = minLength * 8;
      const avalanchePercentage = (flippedBits / totalBits) * 100;
      avalancheScores.push(avalanchePercentage);
      
      if ((i + 1) % Math.max(1, Math.floor(iterations / 10)) === 0) {
        console.log(`Progress: ${i + 1}/${iterations} pairs analyzed`);
      }
    }
    
    const endTime = performance.now();
    const duration = (endTime - startTime) / 1000;
    
    const mean = avalancheScores.reduce((a, b) => a + b, 0) / avalancheScores.length;
    const stdDev = this._calculateStdDev(avalancheScores);
    const min = Math.min(...avalancheScores);
    const max = Math.max(...avalancheScores);
    
    const deviationFrom50 = Math.abs(mean - 50);
    const passed = deviationFrom50 < 5;
    
    const results = {
      rngType: this.rngType,
      iterations,
      meanAvalanche: mean.toFixed(4) + '%',
      stdDev: stdDev.toFixed(4) + '%',
      min: min.toFixed(4) + '%',
      max: max.toFixed(4) + '%',
      deviationFrom50: deviationFrom50.toFixed(4) + '%',
      ideal: '50% ± 5%',
      duration: duration.toFixed(2) + 's',
      passed: passed
    };
    
    console.log('\nResults:');
    console.log(`Mean Avalanche: ${results.meanAvalanche} (ideal: ${results.ideal})`);
    console.log(`StdDev: ${results.stdDev}`);
    console.log(`Range: [${results.min}, ${results.max}]`);
    console.log(`Deviation from 50%: ${results.deviationFrom50}`);
    console.log(`Duration: ${results.duration}`);
    console.log(`Test Status: ${results.passed ? 'PASSED ✓' : 'FAILED ✗'}`);
    
    this.testResults.push({ test: 'AvalancheEffect', timestamp: Date.now(), results });
    return results;
  }
  
  async verifyIntegrityChecks(level = 'medium') {
    console.log(`\n=== Integrity Checks Verification ===`);
    console.log(`RNG Type: ${this.rngType}`);
    console.log(`Test Level: ${level.toUpperCase()}`);
    
    const results = {
      rngType: this.rngType,
      level,
      minEventsEnforced: false,
      overrideIgnored: false,
      integrityChecksPass: {
        constructor: false,
        validation: false,
        generation: false
      },
      constantsValid: false,
      securityType: this.rngType === 'behavioral' ? 'active' : 'placeholder',
      passed: false
    };
    
    const startTime = performance.now();
    
    try {
      // Check minEvents enforcement
      const stats = this.rng.getStats();
      results.minEventsEnforced = stats.minEvents === 500;
      console.log(`minEvents enforcement: ${results.minEventsEnforced ? 'PASS' : 'FAIL'} (value: ${stats.minEvents})`);
      
      // Test override is ignored (create temporary instance)
      if (level === 'medium' || level === 'high' || level === 'extreme') {
        const RNGClass = this.rng.constructor;
        const testInstance = new RNGClass({ minEvents: 100 });
        const testStats = testInstance.getStats();
        results.overrideIgnored = testStats.minEvents === 500;
        console.log(`Override ignored: ${results.overrideIgnored ? 'PASS' : 'FAIL'} (attempted 100, got ${testStats.minEvents})`);
      }
      
      // Verify integrity check methods work
      try {
        const hasEntropy = this.rng.hasMinimumEntropy();
        results.integrityChecksPass.validation = true;
        console.log(`hasMinimumEntropy() integrity check: PASS`);
      } catch (e) {
        console.log(`hasMinimumEntropy() integrity check: FAIL - ${e.message}`);
      }
      
      try {
        await this.rng.generateSeed(true);
        results.integrityChecksPass.generation = true;
        console.log(`generateSeed() integrity check: PASS`);
      } catch (e) {
        console.log(`generateSeed() integrity check: FAIL - ${e.message}`);
      }
      
      results.integrityChecksPass.constructor = true; // If instance exists, constructor passed
      
      // For behavioral RNG, verify constants are correct
      if (this.rngType === 'behavioral') {
        results.constantsValid = results.minEventsEnforced && 
                                 results.integrityChecksPass.validation && 
                                 results.integrityChecksPass.generation;
      } else {
        // For pure-crypto, constants are placeholders (always valid)
        results.constantsValid = true;
      }
      
      console.log(`Constants validation: ${results.constantsValid ? 'PASS' : 'FAIL'}`);
      
      // HIGH/EXTREME: Security edge cases
      if (level === 'high' || level === 'extreme') {
        console.log(`\nSecurity Edge Cases:`);
        
        // Attempt prototype manipulation
        const originalMinEvents = this.rng.minEvents;
        this.rng.minEvents = 10;
        const afterTamper = this.rng.getStats().minEvents;
        const protectedFromTamper = afterTamper === 500;
        this.rng.minEvents = originalMinEvents;
        
        console.log(`  Prototype tampering protection: ${protectedFromTamper ? 'PASS' : 'FAIL'}`);
        
        // Verify getProgress() returns correct requiredEvents
        const progress = this._getEntropyProgress();
        const progressCorrect = progress.requiredEvents === 500;
        console.log(`  getProgress() requiredEvents: ${progressCorrect ? 'PASS' : 'FAIL'} (${progress.requiredEvents})`);
      }
      
      // EXTREME: Multiple initialization attempts
      if (level === 'extreme') {
        console.log(`\nStress Testing (100 initializations)...`);
        const RNGClass = this.rng.constructor;
        let allPassed = true;
        
        for (let i = 0; i < 100; i++) {
          const testRNG = new RNGClass({ minEvents: Math.floor(Math.random() * 1000) });
          if (testRNG.getStats().minEvents !== 500) {
            allPassed = false;
            break;
          }
        }
        
        console.log(`  100 initialization stress test: ${allPassed ? 'PASS' : 'FAIL'}`);
      }
      
      results.passed = results.minEventsEnforced && 
                       results.constantsValid && 
                       results.integrityChecksPass.constructor &&
                       results.integrityChecksPass.validation &&
                       results.integrityChecksPass.generation;
      
    } catch (error) {
      console.error(`Test error: ${error.message}`);
      results.error = error.message;
    }
    
    const endTime = performance.now();
    results.duration = ((endTime - startTime) / 1000).toFixed(2) + 's';
    
    console.log('\nResults:');
    console.log(`Security Type: ${results.securityType}`);
    console.log(`minEvents Enforced: ${results.minEventsEnforced ? 'YES' : 'NO'}`);
    console.log(`Override Ignored: ${results.overrideIgnored ? 'YES' : 'NO'}`);
    console.log(`Constants Valid: ${results.constantsValid ? 'YES' : 'NO'}`);
    console.log(`Integrity Checks: Constructor=${results.integrityChecksPass.constructor}, ` +
                `Validation=${results.integrityChecksPass.validation}, ` +
                `Generation=${results.integrityChecksPass.generation}`);
    console.log(`Duration: ${results.duration}`);
    console.log(`Test Status: ${results.passed ? 'PASSED ✓' : 'FAILED ✗'}`);
    
    this.testResults.push({ test: 'IntegrityChecks', timestamp: Date.now(), results });
    return results;
  }
  
  async verifyAPICompatibility(level = 'medium') {
    console.log(`\n=== API Compatibility Verification ===`);
    console.log(`RNG Type: ${this.rngType}`);
    console.log(`Test Level: ${level.toUpperCase()}`);
    
    const requiredMethods = [
      'generateSeed',
      'generateSeedHex',
      'generateSeedBase64',
      'generateSalt',
      'combineEntropy',
      'hasMinimumEntropy',
      'getProgress',
      'getStats',
      'clearEntropy',
      'startCollecting',
      'stopCollecting',
      'toHex',
      'toBase64'
    ];
    
    const results = {
      rngType: this.rngType,
      level,
      methodsPresent: 0,
      methodsRequired: requiredMethods.length,
      missingMethods: [],
      outputFormatsValid: false,
      behaviorExpected: false,
      passed: false
    };
    
    const startTime = performance.now();
    
    try {
      // Check method existence
      console.log(`\nMethod Existence Check:`);
      for (const method of requiredMethods) {
        if (typeof this.rng[method] === 'function') {
          results.methodsPresent++;
        } else {
          results.missingMethods.push(method);
          console.log(`  ${method}: MISSING`);
        }
      }
      console.log(`Methods present: ${results.methodsPresent}/${results.methodsRequired}`);
      
      // MEDIUM+: Output format validation
      if (level !== 'low') {
        console.log(`\nOutput Format Validation:`);
        
        const seed = await this.rng.generateSeed(true);
        const seedHex = await this.rng.generateSeedHex(true);
        const seedBase64 = await this.rng.generateSeedBase64(true);
        const salt = this.rng.generateSalt();
        const progress = this._getEntropyProgress();
        const stats = this.rng.getStats();
        
        const checks = {
          seedIsUint8Array: seed instanceof Uint8Array,
          seedLength64: seed.length === 64,
          hexIsString: typeof seedHex === 'string',
          hexLength128: seedHex.length === 128,
          hexValidFormat: /^[0-9a-f]{128}$/.test(seedHex),
          base64IsString: typeof seedBase64 === 'string',
          base64Valid: /^[A-Za-z0-9+/]+=*$/.test(seedBase64),
          saltIsUint8Array: salt instanceof Uint8Array,
          progressHasFields: progress.hasOwnProperty('currentEvents') && 
                             progress.hasOwnProperty('requiredEvents') &&
                             progress.hasOwnProperty('percentage') &&
                             progress.hasOwnProperty('ready'),
          progressRequiredIs500: progress.requiredEvents === 500,
          statsHasFields: stats.hasOwnProperty('minEvents') &&
                          stats.hasOwnProperty('totalEvents') &&
                          stats.hasOwnProperty('hasMinimumEntropy'),
          statsMinEventsIs500: stats.minEvents === 500
        };
        
        for (const [check, result] of Object.entries(checks)) {
          console.log(`  ${check}: ${result ? 'PASS' : 'FAIL'}`);
        }
        
        results.outputFormatsValid = Object.values(checks).every(v => v === true);
      }
      
      // HIGH+: Behavioral validation
      if (level === 'high' || level === 'extreme') {
        console.log(`\nBehavioral Validation:`);
        
        const progress = this._getEntropyProgress();
        const stats = this.rng.getStats();
        
        if (this.rngType === 'behavioral') {
          // ntrpRNG expected behavior
          const behaviorChecks = {
            canHaveNotReady: true, // Progress can be < 100%
            hasEntropyArrays: Array.isArray(this.rng.entropyPool) && Array.isArray(this.rng.timerDeltas),
            eventCountIsObject: typeof this.rng.eventCount === 'object'
          };
          
          for (const [check, result] of Object.entries(behaviorChecks)) {
            console.log(`  [ntrpRNG] ${check}: ${result ? 'PASS' : 'FAIL'}`);
          }
          
          results.behaviorExpected = Object.values(behaviorChecks).every(v => v === true);
          
        } else {
          // cgRNDV expected behavior
          const behaviorChecks = {
            alwaysReady: progress.ready === true,
            progressAlways100: progress.percentage === 100,
            poolSizeAlways0: stats.entropyPoolSize === 0,
            totalEventsAlways0: stats.totalEvents === 0,
            hasMinEntropyAlwaysTrue: stats.hasMinimumEntropy === true
          };
          
          for (const [check, result] of Object.entries(behaviorChecks)) {
            console.log(`  [cgRNDV] ${check}: ${result ? 'PASS' : 'FAIL'}`);
          }
          
          results.behaviorExpected = Object.values(behaviorChecks).every(v => v === true);
        }
      }
      
      // EXTREME: Stress test with multiple calls
      if (level === 'extreme') {
        console.log(`\nStress Testing (100 method calls)...`);
        let callsSuccessful = 0;
        
        for (let i = 0; i < 100; i++) {
          try {
            await this.rng.generateSeed(true);
            this.rng.getProgress();
            this.rng.getStats();
            this.rng.generateSalt();
            callsSuccessful++;
          } catch (e) {
            console.log(`  Call ${i + 1} failed: ${e.message}`);
          }
        }
        
        console.log(`  Successful calls: ${callsSuccessful}/100`);
        results.stressTestPassed = callsSuccessful === 100;
      }
      
      results.passed = results.methodsPresent === results.methodsRequired &&
                       (level === 'low' || results.outputFormatsValid) &&
                       (level === 'low' || level === 'medium' || results.behaviorExpected) &&
                       (level !== 'extreme' || results.stressTestPassed);
      
    } catch (error) {
      console.error(`Test error: ${error.message}`);
      results.error = error.message;
    }
    
    const endTime = performance.now();
    results.duration = ((endTime - startTime) / 1000).toFixed(2) + 's';
    
    console.log('\nResults:');
    console.log(`Methods Present: ${results.methodsPresent}/${results.methodsRequired}`);
    if (results.missingMethods.length > 0) {
      console.log(`Missing Methods: ${results.missingMethods.join(', ')}`);
    }
    console.log(`Output Formats Valid: ${results.outputFormatsValid ? 'YES' : 'N/A'}`);
    console.log(`Behavior Expected: ${results.behaviorExpected ? 'YES' : 'N/A'}`);
    console.log(`Duration: ${results.duration}`);
    console.log(`Test Status: ${results.passed ? 'PASSED ✓' : 'FAILED ✗'}`);
    
    this.testResults.push({ test: 'APICompatibility', timestamp: Date.now(), results });
    return results;
  }
  
  async runTestSuite(level = 'medium') {
    const levels = {
      low: {
        multiSeed: { count: 10, size: 32 },
        monitor: { interval: 100, samples: 30 },
        salt: { iterations: 100 },
        jitter: { samples: 100 },
        repeatability: { iterations: 2 },
        avalanche: { iterations: 10 },
        integrity: 'low',
        apiCompat: 'low'
      },
      medium: {
        multiSeed: { count: 50, size: 64 },
        monitor: { interval: 50, samples: 60 },
        salt: { iterations: 500 },
        jitter: { samples: 500 },
        repeatability: { iterations: 5 },
        avalanche: { iterations: 25 },
        integrity: 'medium',
        apiCompat: 'medium'
      },
      high: {
        multiSeed: { count: 100, size: 64 },
        monitor: { interval: 20, samples: 100 },
        salt: { iterations: 1000 },
        jitter: { samples: 1000 },
        repeatability: { iterations: 10 },
        avalanche: { iterations: 50 },
        integrity: 'high',
        apiCompat: 'high'
      },
      extreme: {
        multiSeed: { count: 500, size: 128 },
        monitor: { interval: 10, samples: 300 },
        salt: { iterations: 5000 },
        jitter: { samples: 5000 },
        repeatability: { iterations: 20 },
        avalanche: { iterations: 100 },
        integrity: 'extreme',
        apiCompat: 'extreme'
      }
    };
    
    const params = levels[level.toLowerCase()] || levels.medium;
    
    console.log(`\n${'='.repeat(50)}`);
    console.log(`RUNNING TEST SUITE - ${level.toUpperCase()} LEVEL`);
    console.log(`RNG Type: ${this.rngType}`);
    if (this.usesWeightedCounting) {
      console.log(`Weighted Counting: ENABLED`);
    }
    console.log('='.repeat(50));
    
    const suiteStart = Date.now();
    
    const results = {
      level,
      rngType: this.rngType,
      weightedCounting: this.usesWeightedCounting,
      timestamp: suiteStart,
      tests: {}
    };
    
    // Universal tests (run for all RNG types)
    results.tests.multiSeed = await this.runMultiSeedTest(
      params.multiSeed.count,
      params.multiSeed.size
    );
    
    results.tests.salt = await this.verifySaltConsistency(params.salt.iterations);
    
    results.tests.repeatability = await this.checkRepeatability(
      params.repeatability.iterations
    );
    
    results.tests.avalanche = await this.testAvalancheEffect(
      params.avalanche.iterations
    );
    
    results.tests.integrity = await this.verifyIntegrityChecks(params.integrity);
    
    results.tests.apiCompat = await this.verifyAPICompatibility(params.apiCompat);
    
    // Behavioral-only tests
    if (this.supportsBehavioralTests()) {
      await this.monitorEntropyPool(
        params.monitor.interval,
        params.monitor.samples
      );
      
      results.tests.jitter = await this.analyzeTimingJitter(params.jitter.samples);
    } else {
      console.log(`\nSkipping behavioral tests (monitorEntropyPool, analyzeTimingJitter)`);
      console.log(`Reason: ${this.rngType} RNG does not support behavioral entropy collection\n`);
    }
    
    const suiteEnd = Date.now();
    const totalDuration = ((suiteEnd - suiteStart) / 1000).toFixed(2);
    
    console.log(`\n${'='.repeat(50)}`);
    console.log(`TEST SUITE COMPLETE - Duration: ${totalDuration}s`);
    console.log(`RNG Type: ${this.rngType}`);
    console.log(`Tests Run: ${Object.keys(results.tests).length}`);
    console.log('='.repeat(50));
    
    return results;
  }
  
  getTestResults() {
    return this.testResults;
  }
  
  clearTestResults() {
    this.testResults = [];
  }
}

// Export
if (typeof module !== 'undefined' && module.exports) {
  module.exports = ntrpRNGDev;
}

if (typeof window !== 'undefined') {
  window.ntrpRNGDev = ntrpRNGDev;
}